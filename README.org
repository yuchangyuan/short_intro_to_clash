#+title: A short introduction to Clash
#+author: Yù Chāngyuǎn

# use large font, run below command with C-x C-e
# (set-frame-font "Ubuntu Mono-48")
# (refresh-font)

* a short self intro
- digital IC design engineer
- interested in FOSS, long time GNU/Linux user
- familiar with functional programming
* what is Clash
** description
- Clash is a functional hardware description language that borrows both its syntax and semantics from the functional programming language Haskell.
- compile a subset of Haskell to synthesizable HDL(verilog/VHDL/systemverilog)
** features
- Strongly typed
- Interactive REPL(clashi)
- Low-level access(blackbox)
* simplified intro for Haskell
** ghc/ghci
- ghc: Glasgow Haskell Compiler
- ghci: REPL from ghc
  + :t, type
  + :i, info
** pure
- every function has no side effect
** lazy evaluation
- do not apply unless necessary
- list & infinite list
** high order function, function vs variable
- function is variable
- ordinary variable is function with 0 args
- so, variable is immutable
** curry
- f x y = (f x) y
- f x y z = (f x y) z = ((f x) y) z
- let add = (+)
- let f5 = add 5
- f5 6 == 11
** Functor/Applicative
*** Functor, fmap
- container with some type
  + []
  + Maybe
- fmap (+ 1) [1,2,3] == [2,3,4]
- fmap (+ 1) $ Just 4 == Just 5
- fmap (+ 1) None == None
*** Applicative, <*>
- container, can appy inside container
- [(* 2)] <*> [1, 2, 3]
- Just (+ 5) <*> Just 6
- pure (+) <*> Just 5 <*> Just 6
* try some code in ghci
** reciprocal calculation
#+begin_src haskell
-- reciprocal calculate, 1/d
f d x = x * (2 - d * x)

f 0.7 1
(f 0.7) 1
f 0.7 $ 1

f 0.7 $ f 0.7 $ 1
f 0.7 $ f 0.7 $ f 0.7 $ 1


(f 0.7) . (f 0.7) . (f 0.7) $ 1
#+end_src
** make a function
#+begin_src haskell
foldr (.) id [f 0.7, f 0.7, f 0.7] $ 1

foldr (.) id (replicate 3 $ f 0.7) $ 1

recipI n d = foldr (.) id (replicate n $ f d) $ 1
#+end_src
* ~Signal~ in Clash
#+begin_src haskell
data Signal (dom :: Domain) a
  = a :- Signal dom a

head# :: Signal dom a -> a
head# (x' :- _ )  = x'

tail# :: Signal dom a -> Signal dom a
tail# (_  :- xs') = xs'
#+end_src

#+begin_src haskell
instance Functor (Signal dom)
instance Applicative (Signal dom)
#+end_src

** compare to List
#+begin_src haskell
data [] a = [] | a : [a]
#+end_src

** try in clashi
- sampleN @System 5 $ (pure 4)

- a = fromList [1..]
- sampleN @System 10 $ a

- b = fromList [2..]
- sampleN @System 10 $ b

- c = a * (pure 2)
- sampleN @System 10 $ c

- sampleN @System 10 $ b + c
* combinational logic
** for number signal, just apply normal operation
#+begin_src haskell
instance Num a => Num (Signal dom a)
instance Fractional a => Fractional (Signal dom a)
#+end_src

** for other type, use ~fmap~, ~pure~ & ~<*>~, or helper function: ~.==.~, ~.<.~ ...
#+begin_src haskell
instance Functor (Signal dom)
instance Applicative (Signal dom)
#+end_src

- sampleN @System 10 $ fmap not $ pure False
- sampleN @System 10 $ not  <$> pure False
- sampleN @System 10 $ Just <$> fromList [1..]
- sampleN @System 10 $ pure not <*> pure False
- sampleN @System 10 $ pure 5 .>. fromList [1..]
* sequential logic
#+begin_src haskell
register ::
  (HiddenClockResetEnable dom, NFDataX a) =>
  a -> Signal dom a -> Signal dom a
        -- Defined in ‘Clash.Signal’
infixr 3 `register`
#+end_src

- a = fromList [1..]
- b = register 8 a
- sampleN @System 10 b -- NOTE, first 1 power-up value, then reset value
- simulateN @System 10 (register 8) [1..] -- power-up value not included

- x = let { a = register False b; b = fmap not a } in a
- sampleN @System 10 x

* trival example, FIR Filter
#+begin_src haskell
fir coeffs x = dotp coeffs (window x)
  where
    dotp as bs = sum (zipWith (*) as bs)

-- inferred: Signal dom Int -> Signal dom Int
fir3int = fir (3 :> 4 :> 5 :> Nil)

-- inferred: Signal dom Float -> Signal dom Float
fir4float = fir (3.5 :> 4.2 :> 3.0 :> 6.1 :> Nil)
#+end_src

see [[./src/FIR.hs]]
* non trival example, reciprocal calculation
** function
see [[./src/Recip.hs]]
#+begin_src haskell
import Data.List as L
import Prelude as P

f d x = x * (2 - d * x)

recipI :: (Num a) => Int -> a -> a
recipI n d = L.foldr (.) id (L.replicate n $ f d) $ 1

recipFull :: (Scalable a) => Int -> a -> a
recipFull k x = scale (recipI k y) (-n)
  where
    (y, n) = unscale x
#+end_src

#+begin_src haskell
class RealFrac a => Scalable a where
  unscale :: Integral b => a -> (a, b)
  scale :: Integral b => a -> b -> a
#+end_src
** trival test
[[./tb/tb_recip.v]]
#+begin_src verilog
module tb;
   wire [31:0] out1, out2;
   reg [31:0]  in;

   localparam  SCALE = 'h100_0000;

   recip4_ dut1(.x(in), .y(out1));
   recip4  dut2(.x(in), .y(out2));

   task t(input real x);
      begin
         in = x * SCALE;
         #1;
         $display("%f:\t%.9f\t%.9f", x, 1.0 * out1 / SCALE, 1.0 * out2 / SCALE);
      end
   endtask

   initial begin
      $display("input:\t\trecip4_\t\trecip4");
      t(0.1);
      t(0.3);
      t(0.5);
      t(0.7);
      t(1.0);
      t(1.8);
      t(2.5);
      t(3.0);
   end
endmodule
#+end_src
** sequential implementation
- one iteration per cycle
- register unscale step
- register scale step
- chisel DecoupledIO alike IO
  + in_data, in_esp, in_valid, in_ready
  + out_data, out_valid, out_ready
*** all state
- ~y~, unscale from in_data, when input ready
- ~n~, unscale from in_data, when input ready
- ~esp~, register when input ready
- ~state~ , state of state machine
- ~res~, unscaled result
- ~out_data~, scale from ~res~ & ~n~
*** state machine
- state
  + IDLE
  + BUSY
  + DONE
- output
  + in_ready <= state == IDLE
  + out_valid <= state == DONE
- transition
  + IDLE -> BUSY
    condition: in_ready & in_valid
    state: (y, n) <= unscale in_data, res <= 1.0
  + BUSY -> DONE
    condition: abs(res - res') < esp -> DONE
    state: out_data <= scale res n
  + DONE -> IDLE
    condition: out_valid & out_ready
*** wire
- res' = res * (2 - y * res)
* compare to other (HDL) language
* refs
- https://downloads.haskell.org/ghc/latest/docs/html/users_guide/
- https://hackage.haskell.org/package/clash-prelude-1.6.3/docs/Clash-Prelude.html
- https://hackage.haskell.org/package/clash-prelude-1.6.3/docs/Clash-Signal.html
- https://hackage.haskell.org/package/clash-prelude-1.6.3/docs/src/Clash.Signal.Internal.html#Signal
- https://hackage.haskell.org/package/clash-prelude-1.6.3/docs/Clash-Annotations-TopEntity.html#v:Synthesize
